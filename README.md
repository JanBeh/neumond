# Algebraic effect handling and asynchronous I/O in Lua

This library is work in progress.

## Module `effect`

Module for algebraic effect handling implemented in pure Lua.

  * **`perform(eff)`** performs the effect `eff`.

  * **`handle(handlers, action, ...)`** calls the `action` function with given
    arguments and, during execution of the action function, handles those
    effects which are listed as key in the `handlers` table. The value in the
    handlers table is the corresponding handler, which is is a function that
    retrieves a continuation function (usually named "`resume`") as first
    argument. The handler may resume the action only *before* returning.

  * **`handle_once(handlers, action, ...)`** does the same as `handle`, but:

    * allows resuming the action also after a handler has returned;
    * does not automatically handle further effects after resuming the action.

  * **`discontinue(resume)`** releases a continuation (`"resume"`) passed to an
    effect handler by unwinding the stack of the interrupted action. It is
    only applicable for continuations generated by `handle_once` but must not
    be used for continuations generated by `handle` as continuations generated
    by the `handle` function are automatically discontinued when an effect
    handler returns (or throws an error) without resuming.

## Module `fiber`

Module for lightweight threads implemented in pure Lua by using the `effect`
module.

Note that it is required to run `fiber.main(action, ...)` before any other
functions of this module can be used. All other functions *must* be called
within the `action` function.

  * **`fiber.main(action, ...)`** runs the `action` function with given
    arguments as main fiber which may spawn additional fibers. It returns the
    return values of the main fiber when execution of all fibers has stopped
    (i.e. when all fibers have terminated or are sleeping).

  * **`fiber.current()`** obtains a handle for the currently running fiber.

  * **`fiber.sleep()`** puts the currently running fiber to sleep.

  * **`fiber.yield()`** allows the main loop to execute a different fiber.

  * **`fiber.spawn(action, ...)`** runs the `action` function with given
    arguments in a separate fiber and returns a handle for the spawned fiber.

A fiber handle `f` provides the following attributes and methods:

  * **`f.results`** is a table containing the return value of the action
    function of fiber `f`, or `nil` if the action has not terminated yet.

  * **`f:await()`** puts the currently running fiber to sleep until fiber `f`
    has terminated. The method then returns its return values.

