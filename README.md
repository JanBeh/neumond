# One-shot algebraic effect handling and asynchronous I/O in Lua

This library is work in progress.

## Module `effect`

Module for algebraic effect handling implemented in pure Lua.

  * **`effect.new(name)`** returns an object that is suitable to be used as an
    effect. Note that any other object can be used as an effect as well, but an
    object `x` returned by this function is automatically callable such that
    `x(...)` is a short form for `effect.perform(x, ...)`. Moreover, the
    generated object has a string representation (using the `__tostring`
    metamethod) based on the `name` and a suffix, which may be useful for
    debugging.

  * **`effect.perform(eff, ...)`** performs the effect `eff` with optional
    arguments.

  * **`effect.handle(handlers, action, ...)`** calls the `action` function with
    given arguments and, during execution of the action function, handles those
    effects which are listed as key in the `handlers` table. The value in the
    handlers table is the corresponding handler, which is is a function that
    retrieves a continuation function (usually named "`resume`") as first
    argument followed by optional arguments that have been passed to the
    `effect.perform` function. Handlers in the `handlers` table passed to the
    `effect.handle` function may resume the action only *before* returning.

  * **`effect.handle_once(handlers, action, ...)`** does the same as `handle`,
    but:

    * allows resuming the action also after a handler has returned;
    * does not automatically handle further effects after resuming the action.

  * **`effect.discontinue(resume)`** releases a continuation (`resume`) passed
    to an effect handler by unwinding the stack of the interrupted action. It
    is only applicable for continuations generated by `effect.handle_once` but
    must not be used for continuations generated by `effect.handle` as
    continuations generated by the `effect.handle` function are automatically
    discontinued when an effect handler returns (or throws an error) without
    resuming.

## Module `fiber`

Module for lightweight threads implemented in pure Lua by using the `effect`
module.

Note that it is required to run `fiber.main(action, ...)` before any other
functions of this module can be used. All other functions *must* be called from
within the `action` function.
In order to automatically apply effect handlers also to all spawned fibers, it
can be helpful to use the module **`fiber.effect_mod`**, which contains all
items from `effect` but replaces the `handle` function with `fiber.handle`,
that is aware of fibers.
A typical program could thus look as follows:

```
local fiber = require "fiber"
local effect = fiber.effect_mod -- use modded effect module

return fiber.main(function()
  -- code goes here
end)
```

The fiber module provides the following functions:

  * **`fiber.main(action, ...)`** runs the `action` function with given
    arguments as main fiber which may spawn additional fibers. It returns the
    return values of the main fiber when execution of all fibers has stopped
    (i.e. when all fibers have terminated or are sleeping).

  * **`fiber.current()`** obtains a handle for the currently running fiber.

  * **`fiber.sleep()`** puts the currently running fiber to sleep.

  * **`fiber.yield()`** allows the main loop to execute a different fiber.

  * **`fiber.spawn(action, ...)`** runs the `action` function with given
    arguments in a separate fiber and returns a handle for the spawned fiber.

  * **`fiber.handle(handlers, action, ...)`** acts like `effect.handle` but
    additionally applies the effect handling to all spawned fibers. Thus
    `fiber.handle` will not return until all fibers have terminated.
    This function is also available as `fiber.effect_mod.handle`.

A fiber handle `f` provides the following attributes and methods:

  * **`f:wake()`** wakes up fiber `f`.

  * **`f.results`** is a table containing the return value of the action
    function of fiber `f`, or `nil` if the action has not terminated yet.

  * **`f:await()`** puts the currently running fiber to sleep until fiber `f`
    has terminated. The method then returns its return values.

## Related work

See also ["One-shot Algebraic Effects as Coroutines"](http://logic.cs.tsukuba.ac.jp/~sat/pdf/tfp2020-postsymposium.pdf), 21st International Symposium on Trends in Functional Programming (TFP), 2020, (post symposium) by Satoru Kawahara and Yukiyoshi Kameyama, Department of Computer Science, University of Tsukuba, Japan, who provide theoretic background and also presented a similar [implementation](https://github.com/Nymphium/eff.lua) of (one-shot) algebraic effects in Lua based on coroutines.
